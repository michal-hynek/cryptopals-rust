pub fn xor(x: &[u8], y: &[u8]) -> Vec<u8> {
    let mut x_xor_y = Vec::with_capacity(x.len());

    for (i, x_char) in x.iter().enumerate() {
        x_xor_y.push(x_char ^ y[i % y.len()]);
    }

    x_xor_y
}

#[cfg(test)]
mod test_xor {
    use super::*;

    #[test]
    fn test_xor_single_byte() {
        assert_eq!(vec![0x0], xor(&[0x0], &[0x0]));
        assert_eq!(vec![0x1], xor(&[0x1], &[0x0]));
        assert_eq!(vec![0x1], xor(&[0x0], &[0x1]));
        assert_eq!(vec![0x0], xor(&[0x1], &[0x1]));
    }

    #[test]
    fn test_xor_multiple_bytes() {
        let x = [
            0x1c, 0x01, 0x11, 0x00, 0x1f, 0x01, 0x01,
            0x00, 0x06, 0x1a, 0x02, 0x4b, 0x53, 0x53,
            0x50, 0x09, 0x18, 0x1c
        ];
        let y = [
            0x68, 0x69, 0x74, 0x20, 0x74, 0x68, 0x65,
            0x20, 0x62, 0x75, 0x6c, 0x6c, 0x27, 0x73,
            0x20, 0x65, 0x79, 0x65
        ];
        let x_xor_y = vec![
            0x74, 0x68, 0x65, 0x20, 0x6b, 0x69, 0x64,
            0x20, 0x64, 0x6f, 0x6e, 0x27, 0x74, 0x20,
            0x70, 0x6c, 0x61, 0x79
        ];

        let result = xor(&x, &y);

        assert_eq!(x_xor_y, result);
    }
}